import argparse
import hashlib
import os
from base64 import b64decode, b64encode

from cryptography.hazmat.primitives import hashes, serialization
from cryptography.hazmat.primitives.asymmetric import padding, rsa
from cryptography.hazmat.primitives.ciphers.aead import AESGCM
from django.conf import settings
from django.core.management.base import BaseCommand
from django.db import transaction
from django.db.models import Q
from django.test.client import RequestFactory
from django.urls import reverse

from ...actions.update import create_key_fn
from ...models import Net, Cluster
from ...utils.misc import hash_object


def _gen_key_vars_nohash(inp: bytes | str):
    if isinstance(inp, str):
        return (
            b64decode(inp),
            inp,
        )
    return inp, b64encode(inp).decode("ascii")


def _gen_key_vars(inp: bytes | str):
    ret = _gen_key_vars_nohash(inp)
    return *ret, hash_object(ret[0])


class Command(BaseCommand):
    help = "Create cluster"

    def add_arguments(self, parser):
        parser.add_argument(
            "--key", default=None, help="PrivateKey encryption key"
        )
        parser.add_argument("--bits", "-b", type=int, default=4096)
        parser.add_argument("--net", default=None)
        parser.add_argument(
            "--public-key-state",
            default="trusted",
            choices=["public", "trusted", "required"],
        )
        parser.add_argument("cluster")
        parser.add_argument(
            "out",
            nargs="?",
            default=None,
            type=argparse.FileType("wb"),
            help="Ceritificate out (Public+Private Part)",
        )

    def handle(self, **options):
        if not options["key"]:
            options["key"] = b64encode(os.urandom(32)).decode("ascii")
        cluster = Cluster.objects.get(
            Q(flexid=options["cluster"]) | Q(flexid_cached=options["cluster"])
        )
        if options["net"]:
            if options["net"].isdigit():
                net = Net.objects.get(id=options["net"])
            else:
                net = Net.objects.get(
                    Q(cluster__flexid=options["net"])
                    | Q(cluster__flexid_cached=options["net"])
                )
        else:
            net = cluster.net
        hash_algo = hashlib.new(settings.SECRETGRAPH_HASH_ALGORITHMS[0])
        hash_algo_name = hash_algo.name
        hash_algo = getattr(hashes, hash_algo_name.upper())()
        nonce_privkey = os.urandom(13)
        privkey_key, privkey_key_b64 = _gen_key_vars_nohash(options["key"])
        privateKey = rsa.generate_private_key(
            public_exponent=65537, key_size=options["bits"]
        )
        privateKey_bytes = privateKey.private_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption(),
        )
        publicKey = privateKey.public_key()
        publicKey_bytes = publicKey.public_bytes(
            encoding=serialization.Encoding.DER,
            format=serialization.PublicFormat.SubjectPublicKeyInfo,
        )

        url = reverse("graphql-plain")
        request = RequestFactory().get(url)
        keyfn = create_key_fn(
            request,
            {
                "net": net,
                "cluster": cluster,
                "key": {
                    "publicKey": publicKey_bytes,
                    "publicState": options["public_key_state"],
                    "privateKey": AESGCM(privkey_key).encrypt(
                        nonce_privkey, privateKey_bytes, None
                    ),
                    "nonce": nonce_privkey,
                    "privateTags": (
                        "name=initial private key generated by command",
                        "key={}:{}".format(
                            hash_algo_name,
                            b64encode(
                                publicKey.encrypt(
                                    privkey_key,
                                    padding.OAEP(
                                        mgf=padding.MGF1(algorithm=hash_algo),
                                        algorithm=hash_algo,
                                        label=None,
                                    ),
                                )
                            ).decode("ascii"),
                        ),
                    ),
                    "publicTags": ["name=initial key generated by command"],
                },
            },
        )

        with transaction.atomic():
            result = keyfn()
        print("PublicKey id:", result["public"].flexid_cached)
        print("PrivateKey id:", result["private"].flexid_cached)
        print("PrivateKey encryption key:", options["key"])

        if options["out"]:
            options["out"].write(
                publicKey.public_bytes(
                    encoding=serialization.Encoding.PEM,
                    format=serialization.PublicFormat.SubjectPublicKeyInfo,
                )
            )
            options["out"].write(b"\n")
            options["out"].write(
                privateKey.private_bytes(
                    encoding=serialization.Encoding.PEM,
                    format=serialization.PrivateFormat.PKCS8,
                    encryption_algorithm=serialization.NoEncryption(),
                )
            )
            print("Certificate written")
