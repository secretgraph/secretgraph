type ActionEntry {
  keyHash: String!
  type: String!
  allowedTags: [String!]
}

input ActionInput {
  """Action definition, "delete" for action deletion"""
  value: JSON!
  existingHash: String = null
  start: DateTime = null
  stop: DateTime = null

  """Action key for encrypting action (base64, 32 bytes)"""
  key: String = null
}

type Cluster implements Node {
  id: GlobalID!
  authOk: Boolean!
  availableActions: [ActionEntry!]!
  contents(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    filters: ContentFilterSimple!
  ): ContentConnection!
  deleted: DateTime
  description: String
  featured: Boolean

  """cluster groups: groups for cluster permissions and injected keys"""
  groups: [String!]
  name: String
  primary: Boolean
  properties: [String!]

  """Is cluster public/global"""
  public: Boolean
  updateId: UUID
  updated: DateTime
  user: String
}

"""A connection to a list of items."""
type ClusterConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ClusterEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type ClusterEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Cluster!
}

input ClusterFilter {
  """Search description, id and name"""
  search: String = null
  states: [String!] = null
  includeTypes: [String!] = null
  excludeTypes: [String!] = null
  includeTags: [String!] = null

  """Use id=xy for excluding clusters with content ids"""
  excludeTags: [String!] = null

  """Filter clusters with ids or global name"""
  ids: [ID!] = null

  """Use for excluding clusters with ids or global names"""
  excludeIds: [ID!] = null
  contentHashes: [String!] = null
  featured: UseCriteria! = IGNORE
  primary: UseCriteria! = IGNORE
  deleted: UseCriteria! = FALSE
  public: UseCriteriaPublic! = IGNORE
  minUpdated: DateTime = null
  maxUpdated: DateTime = null
}

type ClusterGroup implements Node {
  id: GlobalID!
  name: String!
  description: String!
  hidden: Boolean!
  injectedKeys: [InjectedKey!]!
  properties: [String!]!
}

input ClusterInput {
  net: ID = null
  name: String = null
  description: String = null
  featured: Boolean = null
  primary: Boolean = null
  actions: [ActionInput!] = null

  """
  add up to two keys initially;note: if out of resources even the cluster is reverted
  """
  keys: [ContentKeyInput!] = null
  groups: [String!] = null
}

type ClusterMutation {
  cluster: Cluster!
  writeok: Boolean!
}

type Content implements Node {
  id: GlobalID!
  nonce: String!
  updated: DateTime!
  contentHash: String
  updateId: UUID!
  type: String!
  state: String!
  deleted: DateTime
  link: String!
  authOk: Boolean!
  availableActions: [ActionEntry!]!
  cluster: Cluster
  properties: [String!]

  """Uses fetch/view group actions to provide statistics"""
  readStatistic: ReadStatistic!
  referencedBy(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    filters: ContentReferenceFilter!
  ): ContentReferenceConnection!
  references(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    filters: ContentReferenceFilter!
  ): ContentReferenceConnection!
  signatures(includeAlgorithms: [String!] = null): [String!]!
  tags(includeTags: [String!] = null, excludeTags: [String!] = null): [String!]!
}

"""A connection to a list of items."""
type ContentConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ContentEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type ContentEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: Content!
}

input ContentFilter {
  states: [String!] = null
  includeTypes: [String!] = null
  excludeTypes: [String!] = null
  includeTags: [String!] = null

  """Use id=xy for excluding contents with ids"""
  excludeTags: [String!] = null
  contentHashes: [String!] = null
  clusters: [ID!] = null
  hidden: UseCriteria! = FALSE
  featured: UseCriteria! = IGNORE
  deleted: UseCriteria! = FALSE
  public: UseCriteriaPublic! = IGNORE
  minUpdated: DateTime = null
  maxUpdated: DateTime = null
}

input ContentFilterSimple {
  states: [String!] = null
  includeTypes: [String!] = null
  excludeTypes: [String!] = null
  includeTags: [String!] = null
  excludeTags: [String!] = null
  contentHashes: [String!] = null
  minUpdated: DateTime = null
  maxUpdated: DateTime = null
  deleted: UseCriteria = null
}

input ContentInput {
  net: ID = null
  cluster: ID = null
  hidden: Boolean = null
  key: ContentKeyInput = null
  value: ContentValueInput = null
  contentHash: String = null
}

input ContentKeyInput {
  """Cleartext public key in der format"""
  publicKey: Upload = null

  """Encrypted private key (requires nonce)"""
  privateKey: Upload = null

  """Metadata tags for private key"""
  privateTags: [String!] = null

  """Metadata tags for public key"""
  publicTags: [String!] = null
  privateActions: [ActionInput!] = null
  publicActions: [ActionInput!] = null

  """automagically distributed between PublicKey and PrivateKey"""
  references: [ReferenceInput!] = null

  """Nonce for private key (base64, 13 bytes)"""
  nonce: String = null
  publicState: String = null
}

type ContentMutation {
  content: Content!
  writeok: Boolean!
}

type ContentReference implements Node {
  id: GlobalID!

  """
  ContentReference group: references are clustered in groups. They are used to signal different functions of the connection
  """
  group: String!
  extra: String!
  deleteRecursive: DeleteRecursive!
  source: Content!
  target: Content!
}

"""A connection to a list of items."""
type ContentReferenceConnection {
  """Pagination data for this connection"""
  pageInfo: PageInfo!

  """Contains the nodes in this connection"""
  edges: [ContentReferenceEdge!]!

  """Total quantity of existing nodes"""
  totalCount: Int
}

"""An edge in a connection."""
type ContentReferenceEdge {
  """A cursor for use in pagination"""
  cursor: String!

  """The item at the end of the edge"""
  node: ContentReference!
}

input ContentReferenceFilter {
  states: [String!] = null
  includeTypes: [String!] = null
  excludeTypes: [String!] = null
  includeTags: [String!] = null
  excludeTags: [String!] = null
  contentHashes: [String!] = null
  deleted: UseCriteria! = FALSE
  groups: [String!] = null
}

input ContentValueInput {
  value: Upload = null
  state: String = null
  type: String = null
  nonce: String = null
  tags: [String!] = null
  actions: [ActionInput!] = null
  references: [ReferenceInput!] = null
}

"""Date with time (isoformat)"""
scalar DateTime

"""Input data for `deleteContentOrCluster` mutation"""
input DeleteContentOrClusterInput {
  ids: [ID!]!
  when: DateTime = null
  authorization: [String!] = null
}

type DeleteContentOrClusterMutation {
  latestDeletion: DateTime
}

"""Specify policy for recursive deletions"""
enum DeleteRecursive {
  """Delete content when referenced content is deleted (default)"""
  TRUE

  """Keep content when referenced content is deleted"""
  FALSE

  """
  Delete content when referenced content is deleted and no other reference with the same group is remaining
  """
  NO_GROUP
}

"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""
scalar GlobalID @specifiedBy(url: "https://relay.dev/graphql/objectidentification.htm")

type InjectedKey {
  link: String!
  contentHash: String!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""Input data for `mark` mutation"""
input MarkInput {
  ids: [ID!]!
  hidden: Boolean = null
  featured: Boolean = null
  active: Boolean = null
  authorization: [String!] = null
}

type MarkMutation {
  updated: [GlobalID!]!
}

"""An enumeration."""
enum MetadataOperations {
  APPEND
  REMOVE
  REPLACE
}

type MetadataUpdateMutation {
  updated: [GlobalID!]!
}

"""Input data for `mutateCluster` mutation"""
input MutateClusterInput {
  cluster: ClusterInput!
  id: GlobalID = null
  updateId: ID = null
  authorization: [String!] = null
}

"""Input data for `mutateContent` mutation"""
input MutateContentInput {
  content: ContentInput!
  id: GlobalID = null
  updateId: ID = null
  authorization: [String!] = null
}

"""Input data for `mutatePushContent` mutation"""
input MutatePushContentInput {
  content: PushContentInput!
  authorization: [String!] = null
}

"""Input data for `mutateTransfer` mutation"""
input MutateTransferInput {
  id: GlobalID!
  url: String = null
  key: String = null
  headers: JSON = null
  authorization: [String!] = null
}

type Mutation {
  secretgraph: SecretgraphMutations!
}

"""An object with a Globally Unique ID"""
interface Node {
  """The Globally Unique ID of this object"""
  id: GlobalID!
}

"""Information to aid in pagination."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

input PushContentInput {
  parent: ID = null
  value: PushContentValueInput!
  net: ID = null
}

type PushContentMutation {
  content: Content!
  actionKey: String
}

input PushContentValueInput {
  value: Upload!
  state: String = null
  type: String!
  nonce: String!
  tags: [String!]! = []
}

type Query {
  secretgraph(authorization: [String!] = null): SecretgraphObject!
  node(
    """The ID of the object."""
    id: GlobalID!
  ): Node!
}

type ReadStatistic {
  last: DateTime
  first: DateTime
  count: Int!
  totalAmount: Int!
}

input ReferenceInput {
  """Can be node id, direct id of content or hash of key"""
  target: ID!
  extra: String = null
  group: String = null
  deleteRecursive: DeleteRecursive = null
}

"""Input data for `regenerateFlexid` mutation"""
input RegenerateFlexidInput {
  ids: [ID!]!
  authorization: [String!] = null
}

type RegenerateFlexidMutation {
  updated: [GlobalID!]!
}

"""Input data for `resetDeletionContentOrCluster` mutation"""
input ResetDeletionContentOrClusterInput {
  ids: [ID!]!
  authorization: [String!] = null
}

type ResetDeletionContentOrClusterMutation {
  restored: [GlobalID!]!
}

type SecretgraphConfig implements Node {
  """The Globally Unique ID of this object"""
  id: GlobalID!
  clusterGroups: [ClusterGroup!]!
  hashAlgorithms: [String!]!

  """Maximal results per relay query"""
  maxRelayResults: Int!
  canDirectRegister: Boolean!
  registerUrl: String
  loginUrl: String
}

type SecretgraphMutations {
  """
  Supports creation or update of:
    public key or key-pair (key): used for further encryption.
    content (value): a content encrypted by public key except public
  """
  updateOrCreateContent(
    """Input data for `mutateContent` mutation"""
    input: MutateContentInput!
  ): ContentMutation!

  """Create a cluster, optionally initialize with a key-(pair)"""
  updateOrCreateCluster(
    """Input data for `mutateCluster` mutation"""
    input: MutateClusterInput!
  ): ClusterMutation!
  deleteContentOrCluster(
    """Input data for `deleteContentOrCluster` mutation"""
    input: DeleteContentOrClusterInput!
  ): DeleteContentOrClusterMutation!
  resetDeletionContentOrCluster(
    """Input data for `resetDeletionContentOrCluster` mutation"""
    input: ResetDeletionContentOrClusterInput!
  ): ResetDeletionContentOrClusterMutation!
  regenerateFlexid(
    """Input data for `regenerateFlexid` mutation"""
    input: RegenerateFlexidInput!
  ): RegenerateFlexidMutation!
  updateMetadata(
    """Input data for `updateMetadata` mutation"""
    input: UpdateMetadataInput!
  ): MetadataUpdateMutation!
  updateMarks(
    """Input data for `mark` mutation"""
    input: MarkInput!
  ): MarkMutation!
  pushContent(
    """Input data for `mutatePushContent` mutation"""
    input: MutatePushContentInput!
  ): PushContentMutation!
  transferContent(
    """Input data for `mutateTransfer` mutation"""
    input: MutateTransferInput!
  ): TransferMutation!
  logoutUser: Void
}

type SecretgraphObject {
  node(
    """The ID of the object."""
    id: GlobalID!
  ): Node
  permissions: [String!]!
  activeUser: String
  clusters(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    filters: ClusterFilter!
  ): ClusterConnection!
  contents(
    """Returns the items in the list that come before the specified cursor."""
    before: String = null

    """Returns the items in the list that come after the specified cursor."""
    after: String = null

    """Returns the first n items from the list."""
    first: Int = null

    """Returns the items in the list that come after the specified cursor."""
    last: Int = null
    filters: ContentFilter!
  ): ContentConnection!
  config: SecretgraphConfig!
}

type SecretgraphSubscriptions {
  subscribeNodeUpdates(ids: [GlobalID!]!, authorization: [String!] = null): [Node!]!
}

type Subscription {
  secretgraph: SecretgraphSubscriptions!
}

type TransferMutation {
  content: Content
}

scalar UUID

"""Input data for `updateMetadata` mutation"""
input UpdateMetadataInput {
  ids: [GlobalID!]!
  state: String = null
  tags: [String!] = null
  references: [ReferenceInput!] = null
  actions: [ActionInput!] = null
  operation: MetadataOperations = APPEND
  authorization: [String!] = null
}

scalar Upload

"""Specify criteria"""
enum UseCriteria {
  TRUE
  FALSE
  IGNORE
}

"""Specify criteria"""
enum UseCriteriaPublic {
  TRUE
  FALSE
  IGNORE

  """Check only token"""
  TOKEN
}

"""Represents NULL values"""
scalar Void